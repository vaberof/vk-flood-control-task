Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему
выбрали именно этот.

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет
больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее
  хранилище данных. Допустимо использовать любое на ваше усмотрение.

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Описание реализации

### Хранилище

Рассматривал варианты Redis и PostgreSQL.
Потенциально вызовов метода Check может быть много, поэтому нужно обеспечить быстрый доступ к данным.
Также мы не привязаны к какой-то определенной схеме имеющейся базы данных.
В итоге остановился на Redis

### Конфигурация

Для конфигурации определил следующие параметры, которые используются в реализации (о них сказано в условии задачи):

- TimeIntervalSeconds (определяет временной интервал, в течение которого действует ограничение вызовов метода Check)
- CallCountLimit (определяет максимальное количество вызовов метода Check в течение временного интервала)

Конфигурационный файл, в котором описываются все необходимые параметры лежит в cmd/floodcontrol/config/container.yaml

### Реализация интерфейса FloodControl

В структуре, которая реализует интерфейс FloodControl нужны следующие параметры:
TimeIntervalSeconds, CallCountLimit и интерфейс для взаимодействия с хранилищем.
Параметры TimeIntervalSeconds и CallCountLimit будут настраиваться через конфиг,
который лежит рядом со структурой в том же файле

В методе Check нужно получить из хранилища данные о том,
когда был сделан последний вызов пользователя и его текущее количество вызовов

После получения данных нужно проверить, прошел ли временной интервал TimeIntervalSeconds с последнего вызова
пользователя,
если да - нужно установить дефолтные значения для параметров LastCallAt=time.Now и CallCount=1,
после следует сохранить данные в хранилище

Если временной интервал TimeIntervalSeconds с последнего вызова еще не прошел,
то нужно проверить, превышен ли уже лимит вызовов CallCountLimit, если да - возвращается ошибка ErrCheckCallLimitExceed,
иначе нужно обновить параметры CallCount=CallCount+1 и LastCallAt=LastCallAt,
после следует сохранить данные в хранилище

Интерфейс FloodControl унес в cmd/floodcontrol/main.go

Реализация интерфейса находится в internal/domain/floodcontrol/flood_control.go

Рядом с реализацией лежит интерфейс InMemoryStorage для взаимодействия с хранилищем и
Payload с необходимыми параметрами LastCallAt и CallCount, который сохраняется в качестве значения в кэше

# Запуск окружения с приложением и Redis

    make docker.run