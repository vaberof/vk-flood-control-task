Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему
выбрали именно этот.

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет
больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее
  хранилище данных. Допустимо использовать любое на ваше усмотрение.

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Описание реализации

### Хранилище

Рассматривал варианты Redis и PostgreSQL.
Потенциально вызовов метода Check может быть много, поэтому нужно обеспечить быстрый доступ к данным. 
Также мы не привязаны к какой-то определенной схеме имеющейся базы данных.
В итоге остановился на Redis

### Конфигурация

Доступны следующие параметры:

- TimeIntervalSeconds (определяет временной интервал, в течение которого действует ограничение вызовов метода Check)
- CallCountLimit (определяет максимальное количество вызовов метода Check в течение временного интервала)

Конфигурационный файл, в котором описываются все необходимые параметры лежит в cmd/floodcontrol/config/container.yaml

### Реализация интерфейса FloodControl

Интерфейс FloodControl находится в cmd/floodcontrol/main.go

Реализация интерфейса находится в internal/domain/floodcontrol/flood_control.go

Рядом с реализацией лежит интерфейс InMemoryStorage для взаимодействия с хранилищем и
payload, который сохраняется в качестве значения в кэше

В методе Check вызывается метод Get интерфейса InMemoryStorage для получения данных из Redis о том,
когда был сделан последний вызов пользователя и его текущее количество вызовов

Затем проверяется, прошел ли временной интервал TimeIntervalSeconds с последнего вызова пользователя,
если да - параметр LastCallAt устанавливается со значением time.Now и параметр CallCount со значением 1, 
после чего данные сохраняются в Redis

Если временной интервал TimeIntervalSeconds с последнего вызова еще не прошел, 
то проверяется превышен ли уже лимит вызовов CallCountLimit,
если да - возвращается ошибка ErrCheckCallLimitExceed,
иначе обновляется параметр CallCount на значение, равное CallCount + 1, а параметр LasCallAt остается с текущим значением,
после чего данные сохраняются в Redis

# Запуск окружения с приложением и Redis

    make docker.run